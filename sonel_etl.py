#sonel_etl.py
import os
import glob
from config.logger import logger
from config.settings import load_config
from database.connection import DatabaseConnection
from database.operations import DataHandler
from extractors.file_extractor import FileExtractor
from extractors.gui_extractor import GUIExtractor
from transformers.voltage_transformer import VoltageTransformer
from utils.validators import extract_client_code

class SonelETL:
    """Clase orquestadora del proceso ETL completo"""
    
    def __init__(self, config_file='config.ini', db_connection=None):
        """
        Inicializa el orquestador ETL
       
        Args:
            config_file: Ruta al archivo de configuraci√≥n
            db_connection: Conexi√≥n a base de datos existente (opcional)
        """
        logger.info("üöÄ Inicializando proceso ETL de Sonel")
        self.config = load_config(config_file)
        
        # Usar conexi√≥n proporcionada o crear una nueva
        if db_connection:
            self.db_connection = db_connection
        else:
            self.db_connection = DatabaseConnection(self.config)
    
    def run(self, extraction_method='file', directory=None, file_path=None):
        """
        Ejecuta el proceso completo de ETL
       
        Args:
            extraction_method: M√©todo de extracci√≥n ('file' o 'gui')
            directory: Directorio espec√≠fico a procesar (opcional)
            file_path: Ruta espec√≠fica a un archivo a procesar (opcional)
           
        Returns:
            bool: True si el proceso fue exitoso
        """
        logger.info(f"üîÅ Iniciando ejecuci√≥n de ETL con m√©todo: {extraction_method}")

        # Si se proporciona un archivo espec√≠fico, procesarlo directamente
        if file_path:
            logger.info(f"Procesando archivo espec√≠fico: {file_path}")
            return self.process_file(file_path)
            
        # Si se proporciona directorio, procesarlo directamente
        if directory or extraction_method == 'file':
            process_dir = directory if directory else self.config['PATHS']['data_dir']
            
            if not os.path.exists(process_dir):
                logger.error(f"‚ùå El directorio {process_dir} no existe")
                return False
                
            return self.process_directory(process_dir)
        
        # Proceso ETL est√°ndar
        # Paso 1: Extracci√≥n
        logger.info("üì• Iniciando extracci√≥n de datos")
        extracted_data = self._extract_data(extraction_method)
        if extracted_data is None:
            logger.error("‚ùå Fallo en la fase de extracci√≥n de datos")
            return False
           
        # Paso 2: Transformaci√≥n
        logger.info("üîß Iniciando transformaci√≥n de datos")
        transformed_data = self._transform_data(extracted_data)
        if transformed_data is None:
            logger.error("‚ùå Fallo en la fase de transformaci√≥n de datos")
            return False
           
        # Paso 3: Carga
        # En el flujo est√°ndar, usamos un c√≥digo gen√©rico ya que no tenemos archivo
        # del cual extraer el c√≥digo
        cliente_codigo = "ETL_STANDARD"
        # Importante: Como no hay archivo, no intentamos extraer c√≥digo de √©l
        handler = DataHandler(self.db_connection)
        cliente_id = handler.get_or_create_codigo_id(cliente_codigo, None, should_extract=False)
        
        if not cliente_id:
            logger.error("‚ùå No se pudo obtener/crear el ID del cliente")
            return False
            
        # Ahora cargamos los datos con el ID ya obtenido
        logger.info(f"‚¨ÜÔ∏è Cargando datos transformados a la base de datos para cliente {cliente_codigo}")
        load_success = handler.insert_data_direct(transformed_data, cliente_id)
        if not load_success:
            logger.error("‚ùå Fallo en la fase de carga de datos")
            return False
           
        logger.info("‚úÖ Proceso ETL completado exitosamente")
        return True
    
    def _extract_data(self, method):
        """
        Ejecuta el paso de extracci√≥n seg√∫n el m√©todo especificado
       
        Args:
            method: M√©todo de extracci√≥n ('file' o 'gui')
           
        Returns:
            DataFrame con los datos extra√≠dos o None si hay error
        """
        if method == 'file':
            extractor = FileExtractor(self.config)
        elif method == 'gui':
            extractor = GUIExtractor(self.config)
        else:
            logger.error(f"M√©todo de extracci√≥n no v√°lido: {method}")
            return None
           
        return extractor.extract()
    
    def _transform_data(self, data):
        """
        Ejecuta el paso de transformaci√≥n de datos
        
        Args:
            data: DataFrame con los datos extra√≠dos
            
        Returns:
            DataFrame transformado o None si hay error
        """
        return VoltageTransformer.transform(data)
    
    def _load_data(self, data, codigo, file_path):
        """
        Ejecuta el paso de carga de datos a la base de datos
       
        Args:
            data: DataFrame con los datos transformados
            codigo: C√≥digo del cliente
            file_path: Ruta al archivo original (para extraer c√≥digo si es necesario)
           
        Returns:
            bool: True si la carga fue exitosa
        """
        logger.info(f"üì¶ Cargando datos para el c√≥digo: {codigo}")
        connection = self.db_connection.get_connection()
        if not connection:
            return False
           
        handler = DataHandler(self.db_connection)
        
        # Determinar si debemos intentar extraer el c√≥digo del archivo
        should_extract = file_path is not None
        return handler.insert_data(data, codigo, file_path, should_extract=should_extract)
    
    def close(self):
        """Cierra las conexiones y recursos"""
        if hasattr(self, 'db_connection') and self.db_connection:
            self.db_connection.close()
            logger.info("üßπ Recursos de ETL liberados correctamente")

    def process_file(self, file_path):
        """
        Procesa un archivo individual
        
        Args:
            file_path: Ruta al archivo a procesar
            
        Returns:
            bool: True si el procesamiento fue exitoso
        """
        try:
            # Validar que el archivo existe
            if not os.path.exists(file_path):
                logger.error(f"‚ùå El archivo {file_path} no existe")
                return False
                
            # Registrar la ruta completa para diagn√≥stico
            logger.info(f"üìÑ Procesando archivo: {file_path}")
                
            # Extraer datos del archivo seg√∫n su tipo
            file_ext = os.path.splitext(file_path)[1].lower()
            if file_ext == '.xlsx':
                from parser.excel_parser import ExcelParser
                df = ExcelParser.parse(file_path)
            elif file_ext == '.csv':
                from parser.csv_parser import CSVParser
                df = CSVParser.parse(file_path)
            else:
                logger.error(f"‚ö†Ô∏è Formato de archivo no soportado: {file_path}")
                return False
            
            if df is None or df.empty:
                logger.error(f"‚ö†Ô∏è No se extrajeron datos del archivo: {file_path}")
                return False
                
            # Transformar datos al formato requerido
            transformed_data = self._transform_data(df)
            
            if transformed_data is None or transformed_data.empty:
                logger.error(f"‚ö†Ô∏è Transformaci√≥n de datos fallida para archivo: {file_path}")
                return False
                
            # Extraer c√≥digo del cliente del nombre del archivo
            cliente_codigo = extract_client_code(file_path)
            
            # En el nuevo sistema, la funci√≥n extract_client_code siempre devuelve un c√≥digo
            # ya sea extra√≠do o generado autom√°ticamente, pero verificamos por si acaso
            if cliente_codigo is None:
                logger.error(f"‚ùå No se pudo obtener c√≥digo de cliente desde el archivo {file_path}")
                return False
            
            logger.info(f"üìå C√≥digo de cliente extra√≠do: {cliente_codigo}")
            success = self._load_data(transformed_data, cliente_codigo, file_path)

            if success:
                logger.info(f"‚úÖ Archivo procesado exitosamente: {file_path} | Cliente: {cliente_codigo}")
                return True
            else:
                logger.error(f"‚ùå Error al cargar datos desde archivo: {file_path}")
                return False
                
        except Exception as e:
            logger.error(f"‚ùå Error cr√≠tico al procesar archivo {file_path}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return False
    
    def process_directory(self, directory=None):
        """
        Procesa todos los archivos de un directorio
        
        Args:
            directory: Directorio a procesar. Si es None, usa el configurado en config
            
        Returns:
            bool: True si se procesaron todos los archivos exitosamente
        """
        if directory is None:
            directory = self.config['PATHS']['data_dir']
            
        if not os.path.exists(directory):
            logger.error(f"‚ùå El directorio {directory} no existe")
            return False
            
        # Buscar todos los archivos compatibles usando el extractor
        file_extractor = FileExtractor(self.config)
        files = file_extractor.find_files_in_directory(directory)
        
        if not files:
            logger.warning(f"‚ö†Ô∏è No se encontraron archivos para procesar en {directory}")
            return True
            
        # Procesar cada archivo - corregido para asegurar que se procesen todos
        total_files = len(files)
        logger.info(f"üìÑ {total_files} archivos encontrados para procesamiento")

        success_count = 0
        for i, file_path in enumerate(files, start=1):
            logger.info(f"üìÇ ({i}/{total_files}) Procesando: {os.path.basename(file_path)}")
            if self.process_file(file_path):
                success_count += 1
            else:
                logger.error(f"‚ùå Fallo al procesar archivo: {file_path}")

        logger.info(f"üìà Resultado final: {success_count}/{total_files} archivos procesados con √©xito")
        return success_count > 0